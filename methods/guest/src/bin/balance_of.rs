#![allow(unused_doc_comments)]
#![no_main]

use alloy_primitives::{Address, U256};
use alloy_sol_types::{sol, SolValue};
use risc0_steel::{
    ethereum::{EthEvmInput, ETH_MAINNET_CHAIN_SPEC},
    Commitment, Contract,
};
use risc0_zkvm::guest::env;

risc0_zkvm::guest::entry!(main);

/// Specify the function to call using the [`sol!`] macro.
/// This parses the Solidity syntax to generate a struct that implements the `SolCall` trait.
sol! {
    /// ERC-20 balance function signature.
    interface IERC20 {
        function balanceOf(address account) external view returns (uint256);
        function totalSupply() external view returns (uint256);
    }
}

/// ABI encodable journal data.
sol! {
    struct Journal {
        Commitment commitment;
        address tokenAddress;
        uint256 circulatingSupply;
        uint256 pastCirculatingSupply;
        uint256 inflationBasisPoints;
    }
}

fn main() {
    // Read the input from the guest environment.
    let input: EthEvmInput = env::read();
    let past_input: EthEvmInput = env::read();
    let token_address: Address = env::read();
    let account: Address = env::read();
    let account_2: Address = env::read();

    // Converts the input into a `EvmEnv` for execution. The `with_chain_spec` method is used
    // to specify the chain configuration. It checks that the state matches the state root in the
    // header provided in the input.
    // let env = input.into_env().with_chain_spec(&ETH_MAINNET_CHAIN_SPEC);
    let env = input.into_env().with_chain_spec(&ETH_MAINNET_CHAIN_SPEC);
    let past_env = past_input
        .into_env()
        .with_chain_spec(&ETH_MAINNET_CHAIN_SPEC);

    // Execute the view call; it returns the result in the type generated by the `sol!` macro.
    let supply_call = IERC20::totalSupplyCall {};
    let balance_of_call = IERC20::balanceOfCall { account };
    let balance_of_call_2 = IERC20::balanceOfCall { account: account_2 };

    ////// Present supply
    let token_contract = Contract::new(token_address, &env);

    // let returns = Contract::new(contract, &env).call_builder(&call).call();
    let total_supply = token_contract.call_builder(&supply_call).call()._0;
    let balance = token_contract.call_builder(&balance_of_call).call()._0;
    let balance_2 = token_contract.call_builder(&balance_of_call_2).call()._0;
    let circulating_supply = total_supply - balance - balance_2;

    ////// Past supply
    // Execute the view call; it returns the result in the type generated by the `sol!` macro.
    let past_token_contract = Contract::new(token_address, &past_env);

    // let returns = Contract::new(contract, &env).call_builder(&call).call();
    let past_total_supply = past_token_contract.call_builder(&supply_call).call()._0;
    let past_balance = past_token_contract.call_builder(&balance_of_call).call()._0;
    let past_balance_2 = past_token_contract
        .call_builder(&balance_of_call_2)
        .call()
        ._0;
    let past_circulating_supply = past_total_supply - past_balance - past_balance_2;

    let inflation_basis_points = ((circulating_supply - past_circulating_supply)
        * U256::from(10000))
        / past_circulating_supply;

    // Commit the block hash and number used when deriving `view_call_env` to the journal.
    let journal = Journal {
        commitment: env.into_commitment(),
        tokenAddress: token_address,
        circulatingSupply: circulating_supply,
        pastCirculatingSupply: past_circulating_supply,
        inflationBasisPoints: inflation_basis_points,
    };
    env::commit_slice(&journal.abi_encode());
}
